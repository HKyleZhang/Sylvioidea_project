#!/bin/bash

######################
# Function 1. Manual #
######################
usage()
{
 echo "Usage: [-a] alignment folder
       [-b] trees folder
       [-c] use codon model
       [-L] a lambda between 0 and 1
       [-m] cluster method: "ward", "kmeans", "MDSK", "pam", "MDSP", "NMDSK" 
       [-k] method of finding potential number of cluster
       [-p] "f" to use fast method; "s" to use slow method; only valid if [-c]
       [-t] number of threads
       [-s] seed number for all tree construction"
}

#########################################################
# Function 2. Extract and root the trees after building #
#########################################################
aftertreebuild()
{
 rm -rf ${1}/${2}_rooted
 mkdir ${1}/${2}_rooted
 for file in ${1}/${2}/*treefile; do
     namepre=$(echo "${file}")
     name=$(basename ${namepre})
     nw_reroot ${file} ZF > ${1}/${2}_rooted/${name}
 done
 if [[ "${3}" -gt 1 ]]; then
     for file in ${1}/${2}_rooted/*treefile; do
         namepre=$(echo "${file}")
         if [[ "${3}" -gt 5 ]]; then
             name=$(basename ${namepre} | cut -d "." -f 1 | cut -d "_" -f 3 | cut -d "-" -f 1)
         else    
             name=$(basename ${namepre} | cut -d "." -f 1 | cut -d "-" -f 2)
         fi 
         seq=$(sed -n "1p" ${file})
         echo "$name $seq" >> ${1}/gnTrees_collection.tre
     done
 fi
}

#########################################################
# Function 3. Make permutation datasets from the output #
#             of fseqboot                               #
#########################################################
makedatasets()
{
 echo -e "The seed for the generation of the 100-replicate permutation data is: ${3}." > impMsg.txt
 i=1
 j=$((i+100))
 filenum=1
 percent=5
 rm -rf ${1}/permutation_data
 mkdir ${1}/permutation_data
 until [[ "${i}" -eq "${j}" ]]; do
     k=$((i+1))
     startnum=$(cat outfile | grep -n "${2}" | cut -d ":" -f 1 | sed -n "${i}p")
     end=$(cat outfile | grep -n "${2}" | cut -d ":" -f 1 | sed -n "${k}p")
     endnum=$((end-1))
     cat ${1}/outfile | sed -n "${startnum},${endnum}p" > ${1}/permutation_data/d${filenum}.phy
     i=$((i+1))
     filenum=$((filenum+1))
 done
}

###################################################
# Function 4. Generate file containing partitions #
###################################################
pl_partition()
{
 seqpos1=1
 seqt=0
 for file in ${1}/${2}/*phy; do 
     name=$(basename "${file}" | cut -d "." -f 1 | cut -d "-" -f 2)
     seq=$(cat ${file} | cut -d " " -f 3)
     seqt=$(echo "$((seqt+seq))")
     echo "${name} = $seqpos1-$seqt;" >> ${1}/Analysis/${3}/partition
     seqpos1=$(echo "$((seqt +1))")
 done
}

####################################################
# Function 5. Sorting out the partitions according #
#             to the clustering results            #
####################################################
partSort()
{
 op=$(echo "${1}_output")   
 lnum=$(cat partition | wc -l)
 pi=1
 while [[ "${pi}" -le "${lnum}" ]]; do
     gnname[$pi]=$(cat partition | sed -n "${pi}p" | cut -d " " -f 1)
     part[$pi]=$(cat partition | sed -n "${pi}p" | cut -d " " -f 3 | cut -d ";" -f 1)
     ((pi++))
 done
 cli=1
 while [[ "${cli}" -le "${lnum}" ]]; do
     cl[$cli]=$(cat ${1} | grep "${gnname[$cli]}" | cut -d " " -f 2)
     ((cli++))
 done
 rm -rf ${op}
 i=1
 k=1
 while [[ "${i}" -le "${lnum}" ]]; do
     if [[ "${i}" -eq "${lnum}" ]]; then
         j=${i}
     else
         j=$((i+1))
     fi
     if [[ "${cl[$i]}" != "NA" ]]; then
         partcon=$(echo "${part[$i]}")
         while [[ "${j}" -le "${lnum}" ]]; do
             if [[ "${cl[$j]}" != "NA" ]]; then
                 if [[ "${cl[$j]}" -eq "${cl[$i]}" ]]; then
                     if [[ "${i}" -lt "${lnum}" ]]; then
                         partcon=$(echo "${partcon},${part[$j]}")
                         cl[$j]="NA"
                     fi
                 fi
             fi
             ((j++))
         done  
         if [[ "${k}" -lt 10 ]]; then
             echo "cluster0${k} = ${partcon}" >> ${op}
         else
             echo "cluster${k} = ${partcon}" >> ${op}
         fi
         ((k++))
     fi
     ((i++))
 done
}

##################################################
# Function 6. Extract and compute log likelihood #
#              of datasets                       #
##################################################
logLXtract()
{
 clfiup=$(ls ${2}/*iqtree | wc -l)
 k=1
 while [[ "${k}" -le "${clfiup}" ]]; do
     if [[ "${k}" -lt 10 ]]; then 
     	 kmd=$(echo "0${k}")
     else 
     	 kmd=${k}
     fi
     logLh=$(cat ${2}/*cluster${kmd}*iqtree | grep "Log-likelihood of the tree:" | cut -d " " -f 5)
     logLhmd=$(echo "${logLh} * 10000" | bc | cut -d "." -f 1 | cut -d "-" -f 2)
     ttllogLhmd=$((ttllogLhmd + logLhmd))
     ((k++))    
 done
 seqname=$(echo "${2}" | rev | cut -d "/" -f 2 | rev)
 echo -e "${seqname} k=${clfiup} -loglikelihood*10^4:\t${ttllogLhmd}" >> ${1}/${seqname}_logLhcollection
}

##############################################
# Function 7. A Fast method to permute based #
#             on codon                       #
##############################################
codonjackkniff()
{
 codir=${1}
 len=${2}
 d=${3}

 codtt=$((len / 3))
 f=$(((codtt / 32767)+1))

 iti=1
 until [[ "${iti}" -gt 1 ]]; do
    r=$(((${RANDOM} * f) / 2 + (codtt / 10)))
    if [[ "${r}" -lt "$((codtt / 2))" ]]; then
        iter=${r}
        ((iti++))
    fi
 done
 
 cp -p ${codir}/aln.ori ${codir}/aln.ori-${d}
 
 i=1
 while [[ "${i}" -le "${iter}" ]]; do
    ri=1
    until [[ "${ri}" -gt 1 ]]; do
        r=$(((${RANDOM} * f)+1))
        if [[ "${r}" -lt "${codtt}" ]]; then
        	p=${r}
        	((ri++))
        fi
    done

    pp=$((p * 3))
    cat ${codir}/aln.ori-${d} | cut -c 1-${pp} > ${codir}/${d}p1.txt
    cat ${codir}/aln.ori-${d} | cut -c $((pp + 1))- > ${codir}/${d}p2.txt

    paste -d "" ${codir}/${d}p2.txt ${codir}/${d}p1.txt > ${codir}/aln.ori-${d}0
    mv ${codir}/aln.ori-${d}0 ${codir}/aln.ori-${d}
    rm -rf ${codir}/aln.ori-${d}0 ${codir}/${d}p1.txt ${codir}/${d}p2.txt
    ((i++))
 done
 paste -d "" ${codir}/taxa ${codir}/aln.ori-${d} > ${codir}/d${d}.part
 cat ${codir}/info ${codir}/d${d}.part > ${codir}/d${d}.phy
 rm -rf ${codir}/aln.ori-${d} ${codir}/d${d}.part
}


##########################
# R code 1. Get clusters #
##########################
get_cluster='if (!require(treespace)) install.packages("treespace")
if (!require(heatmap3)) install.packages("heatmap3")
if (!require(gplots)) install.packages("gplots")
if (!require(cluster)) install.packages("cluster")
if (!require(smacof)) install.packages("smacof")

trees <- read.tree("gnTrees_collection.tre")
clnum <- length(trees)
L <- args1

res <- treespace(trees, method = "treeVec", nf = 2, lambda = L, return.tree.vectors = TRUE)

if ("args2" == "ward") {
   kcd <- res$D
   #######################################################################
   # Multi-Dimensional Scaling for convenience of visualzing the results #
   #######################################################################
   mdres2D <- smacofSym(kcd, ndim = 2, type = "ratio")
   treMDS2D <- as.data.frame(mdres2D$conf)
   write.table(treMDS2D, file = "2-MDS.coord", col.names = FALSE, quote = FALSE)
   write.table(mdres2D$stress, file = "2-MDS.stress", col.names = FALSE, quote = FALSE)
    
   mdres3D <- smacofSym(kcd, ndim = 3, type = "ratio")
   treMDS3D <- as.data.frame(mdres3D$conf)
   write.table(treMDS3D, file = "3-MDS.coord", col.names = FALSE, quote = FALSE)
   write.table(mdres3D$stress, file = "3-MDS.stress", col.names = FALSE, quote = FALSE)

   kcd.hclust <- hclust(kcd, method = "ward.D2")
   svg("dendrogram.svg", width=10, height=10)
   plot(kcd.hclust, cex = 0.6)
   dev.off()

   kcdm <- as.matrix(kcd)
   svg("heatmap-1.svg", width=12, height=12)
   heatmap3(kcdm, Rowv = as.dendrogram(kcd.hclust), symm = TRUE)
   dev.off()

   svg("heatmap-2.svg", width=12, height=12)
   heatmap.2(kcdm, Rowv = as.dendrogram(kcd.hclust), symm = TRUE)
   dev.off()

   dlpre <- as.data.frame(kcd.hclust$labels)
   dl <- dlpre$`kcd.hclust$labels`[order.dendrogram(as.dendrogram(kcd.hclust))]
   dl <- as.data.frame(dl)
   write.table(dl,file = "dend.order", quote = FALSE, col.names = FALSE, row.names = FALSE)

   if (clnum > 11){clnum<-11}

   for(j in 1:clnum){
      cl <- cutree(kcd.hclust, k = j)
       if (j < 10){
          j=paste("0",j,sep= "")
          nj=paste("k",j,".cl",sep = "")
        } else {
          nj=paste("k",j,".cl",sep = "")
        }
      write.table(cl, nj, quote = FALSE, col.names = FALSE)
    }
}

###########################
# K-means on tree vectors #
###########################
if ("args2" == "kmeans") {
   treMDS <- res$pco$li
   write.table(treMDS, file = "2-MDS.coord", col.names = FALSE, quote = FALSE)
   
   treVec <- res$vectors

   if (clnum > 11){
   	  clnum <- 11
    } else {
      clnum <- clnum - 1
    }

   for (j in 1: clnum){
       kc.km <- kmeans(treVec, centers = j, nstart = 50)
       if (j < 10){
          j=paste("0",j,sep= "")
          nj=paste("k",j,".cl",sep = "")
        } else {
          nj=paste("k",j,".cl",sep = "")
        }
        write.table(kc.km$cluster, nj, quote = FALSE, col.names = FALSE)
    }
}

##################################################################
# Multi-Dimensional scaling down to 2D and 3D, K-means on 3D MDS #
##################################################################
if ("args2" == "MDSK") {
	kcd <- res$D
    mdres2D <- smacofSym(kcd, ndim = 2, type = "ratio")
    treMDS2D <- as.data.frame(mdres2D$conf)
    write.table(treMDS2D, file = "2-MDS.coord", col.names = FALSE, quote = FALSE)
    write.table(mdres2D$stress, file = "2-MDS.stress", col.names = FALSE, quote = FALSE)
    
    mdres3D <- smacofSym(kcd, ndim = 3, type = "ratio")
    treMDS3D <- as.data.frame(mdres3D$conf)
    write.table(treMDS3D, file = "3-MDS.coord", col.names = FALSE, quote = FALSE)
    write.table(mdres3D$stress, file = "3-MDS.stress", col.names = FALSE, quote = FALSE)

    if (clnum > 11){
       clnum <- 11
    } else {
       clnum <- clnum - 1
    }

    for (j in 1: clnum){
        kc.km <- kmeans(treMDS3D, centers = j, nstart = 50)
        if (j < 10){
           j=paste("0",j,sep= "")
           nj=paste("k",j,".cl",sep = "")
        } else {
           nj=paste("k",j,".cl",sep = "")
        }
        write.table(kc.km$cluster, nj, quote = FALSE, col.names = FALSE)
    }
}

##############################################
# PAM on the distance/dissimilarities matrix #
##############################################
if ("args2" == "pam") {
   kcd <- res$D

   if (clnum > 11){
   	  clnum <- 11
    } else {
      clnum <- clnum - 1
    }

   for (j in 1: clnum){
       kc.pam <- pam(kcd, diss = TRUE, k = j, cluster.only = TRUE)
       if (j < 10){
          j=paste("0",j,sep= "")
          nj=paste("k",j,".cl",sep = "")
        } else {
          nj=paste("k",j,".cl",sep = "")
        }
        write.table(kc.pam, nj, quote = FALSE, col.names = FALSE)
    }
}

##############################################################
# Multi-Dimensional scaling down to 2D and 3D, PAM on 3D MDS #
##############################################################
if ("args2" == "MDSP") {
	kcd <- res$D
    mdres2D <- smacofSym(kcd, ndim = 2, type = "ratio")
    treMDS2D <- as.data.frame(mdres2D$conf)
    write.table(treMDS2D, file = "2-MDS.coord", col.names = FALSE, quote = FALSE)
    write.table(mdres2D$stress, file = "2-MDS.stress", col.names = FALSE, quote = FALSE)
    
    mdres3D <- smacofSym(kcd, ndim = 3, type = "ratio")
    treMDS3D <- as.data.frame(mdres3D$conf)
    write.table(treMDS3D, file = "3-MDS.coord", col.names = FALSE, quote = FALSE)
    write.table(mdres3D$stress, file = "3-MDS.stress", col.names = FALSE, quote = FALSE)

    if (clnum > 11){
       clnum <- 11
    } else {
       clnum <- clnum - 1
    }

    for (j in 1: clnum){
        kc.pam <- pam(treMDS3D, diss = FALSE, k = j, cluster.only = TRUE)
        if (j < 10){
           j=paste("0",j,sep= "")
           nj=paste("k",j,".cl",sep = "")
        } else {
           nj=paste("k",j,".cl",sep = "")
        }
        write.table(kc.pam, nj, quote = FALSE, col.names = FALSE)
    }
}

###############################################################
# Non-metric Multi-Dimensional scaling down to 2D and K-means #
###############################################################
if ("args2" == "NMDSK") {
	kcd <- res$D
    mdres2D <- smacofSym(kcd, ndim = 2, type = "ordinal")
    treMDS2D <- as.data.frame(mdres2D$conf)
    write.table(treMDS2D, file = "2-MDS.coord", col.names = FALSE, quote = FALSE)
    write.table(mdres2D$stress, file = "2-MDS.stress", col.names = FALSE, quote = FALSE)

    if (clnum > 11){
       clnum <- 11
    } else {
       clnum <- clnum - 1
    }

    for (j in 1: clnum){
        kc.km <- kmeans(treMDS2D, centers = j, nstart = 50)
        if (j < 10){
           j=paste("0",j,sep= "")
           nj=paste("k",j,".cl",sep = "")
        } else {
           nj=paste("k",j,".cl",sep = "")
        }
        write.table(kc.km$cluster, nj, quote = FALSE, col.names = FALSE)
    }
}'

############################################
# R code 2. Format table for visualization #
#           of permutation analysis        #
############################################
logLkhforR_make='out.file <- ""
file.names <- dir(pattern = "logLhcollection")
for(i in 1:length(file.names)){
  file<-read.table(file.names[i])
  out.file <- cbind(out.file, file)
}
write.csv(out.file, file = "logLkhcollection.csv")

da<-read.csv("logLkhcollection.csv")
acdata<-read.table("AutoWZgn_concatenation_logLkhcollection", header = FALSE)
da<-cbind(acdata,da[,3:102])
pernum<-seq(1:100)
names(da)<-c("Actual.data", pernum)
rownum <- nrow(da)

pername<- rep(" ", rownum)
kindex<-seq(1: rownum)
out.file<-cbind(kindex,da$Actual.data,pername,da[,2:101])
names(out.file)<-c("k","Actual data","Permutation data",pernum)
write.csv(out.file, file = "logLkhcollection.csv", row.names = FALSE)

for(k in 1:(rownum - 1)){
  da[k,]<-da[k,]-da[k+1,]
}
da<-rbind(da[1:(rownum - 1),])
dkindex<-seq(1:(rownum - 1))
peravrg<-apply(cbind(da[,2:101]), 1, mean)
persd<-apply(cbind(da[,2:101]), 1, sd)
daforR<-cbind(dkindex,da$Actual.data,peravrg,persd,da[,2:101])
names(daforR)<-c("dk","Actual data","Average","SD",pernum)
write.csv(daforR,file = "logLkhforR.csv", row.names = FALSE)'


#################################################
# R code 3. Plot graph for permutation analysis #
#################################################
graphs='if (!require(ggplot2)) install.packages("ggplot2")
if (!require(tidyr)) install.packages("tidyr")

logdata<-read.csv("logLkhforR.csv")
a<-logdata[,2:3]
write.csv(a,file = "a.csv")
a<-read.csv("a.csv")
a$X=c("k01","k02","k03","k04","k05","k06","k07","k08","k09","k10")
a<-as.data.frame(a)
names(a)<-c("cluster_num","Actual.data","Average")

logdata<-t(logdata)
b<-logdata[5:104,]
write.csv(b, file = "b.csv")
b<-read.csv("b.csv")
names(b)<-c("X","k01","k02","k03","k04","k05","k06","k07","k08","k09","k10")
num<-seq(1:100)
b$X=num
bb<-b[,2:10]
write.csv(bb, file = "b.csv")

a<-gather(a,group,dk,Actual.data:Average)
b<-gather(b,cluster_num,dk,k01:k10)
write.csv(a,file = "amd.csv")
write.csv(b,file = "bmd.csv")

a<-read.csv("amd.csv")
a<-as.data.frame(a)
b<-read.csv("bmd.csv")
b<-as.data.frame(b)

bp<-ggplot(b,aes(cluster_num,dk)) + geom_boxplot(data=b,aes(cluster_num,dk), color="grey")
res<- bp + geom_point(data=a[1:10,], aes(cluster_num,dk, color="Actual data")) + geom_line(data=a[1:10,], aes(cluster_num,dk, color="Actual data"), group=1) + geom_point(data=a[11:20,], aes(cluster_num,dk, color="Permutation data Mean")) + geom_line(data=a[11:20,], aes(cluster_num,dk, color="Permutation data Mean"), group=1)
ggsave("permutation_analysis.svg", width = 15, height = 15)'

####################################################
# R code 4. A way to detect optimal cluster number #
####################################################
find_potent_knum='logd <- read.csv("logLkhforR.csv", header = TRUE)
logd <- abs(logd[,2]-logd[,3])
logdmin <- min(logd, na.rm = TRUE)
min.ind <- which(logd == logdmin)

logper <- seq(1:10)
for (i in 1:9) {
  logper[i+1] <- logd[i+1]/logd[1]
}

res <- array("NA", 10)
j <- 1
threshd <- 0.5
for (i in 1:9){
  if (i >= 2){
    if (logper[i] <= threshd){
      a <- logd[i-1] - logd[i]
      b <- logd[i] - logd[i+1]
      if (b <= a) {
        if (logper[i+1] <= threshd){
        res[j] <- i
        j <- j+1
        }
      }
    }
  }
  else {
    if (logd[i] == logdmin){
      res[j] <- i
      j <- j+1
    }
  }
}
res <- res[res != "NA"]
res <- as.data.frame(res)
write.table(res, file = "potent_knum", quote = FALSE, col.names = FALSE, row.names = FALSE)'

###########################################
# R code 5. Compute square of difference  #
#           between alternative model and #
#           optimal model                 #
###########################################  
editor='if (!require(foreach)) install.packages("foreach")
if (!require(doParallel)) install.packages("doParallel")

no_cores <- detectCores()
registerDoParallel(no_cores)

files <- list.files(pattern = "*model")
foreach(i=files) %dopar% {
    name <- strsplit(i, ".", fixed = TRUE)[[1]][1]
    name <- paste(name, ".txt", sep = "")
  dd <- read.table(i)
  optmodel <- dd[1,2]
  for (k in 1:nrow(dd)){
    dd[k,2] <- round(((dd[k,2] - optmodel) ^ 2), 3)
  }
  write.table(dd[order(dd$V1),], file = name, quote = FALSE, row.names = FALSE, col.names = FALSE)
}'

#######################################
# R code 6. Find the single model for #
#            permutation analysis     #
#######################################
find_model='if (!require(dplyr)) install.packages("dplyr")
dd <- read.table("model.summary")
dd$sum_sq <- apply(dd[,2:ncol(dd)], 1, sum)
dd <- arrange(dd, sum_sq)
write.table(dd, "bestmodel.txt", quote = FALSE, row.names = FALSE, col.names = FALSE)
'

arraypermute='array <- read.table("pos.array")
seednum <- seednumber
set.seed(seednum)

for (i in 1:5){
    seednum <- seednum + 1
    set.seed(seednum)
	p <- sample(array)
	name <- paste(i,".shuffle", sep="")
	write.table(p, file = name, quote = FALSE, row.names = FALSE, col.names = FALSE)
	}
'


###################################################
# Pre-step: Load the flags and check the settings #
###################################################
while getopts "ha:b:cu:L:m:k:p:s:t:" opt
do
  case $opt in
               h) usage && exit;;
               a) alnf=$(echo "${OPTARG}" | cut -d "/" -f 1);;
               b) tref=$(echo "${OPTARG}" | cut -d "/" -f 1);;
               c) cod="y";;
               L) lambda=${OPTARG};;
               m) clustermethod=${OPTARG};;
               k) optik=${OPTARG};;
               p) pmtmethd=${OPTARG};;
               s) iqseed=${OPTARG};;
               t) thr=${OPTARG};;
   esac
done

# No argument returns usage manual and exit
if [[ $OPTIND -eq 1 ]]; then
    usage
    exit
fi

# Get current directory
curdir=$(pwd)

# Resize the terminal window
resize -s 39 80 > /dev/null

# Check if trees folder is defined
if [[ -z "${tref}" ]]; then
    tref="NA"
fi

# If number of thread isn't defined
# detect the number of processors 
if [[ -z "${thr}" ]]; then 
	thr=$(nproc --all)
fi

# Check the lambda setting
if [[ -z "${lambda}" ]]; then
    echo -e "\nERROR: Missing lambda value!"
    exit
fi

# Check the clustering method setting
# Default: Hierachichal clustering with Ward.D2 linkage 
if [[ -z "${clustermethod}" ]]; then 
	clustermethod="ward"
fi	

# If seed isn't defined for IQ-Tree
# generate a random seed
if [[ -z "${iqseed}" ]]; then 
	iqseed=${RANDOM}
fi

# Check method for detecting optimal cluster number
if [[ -z "${optik}" ]]; then
   case ${clustermethod} in
   	   ward) optik="gori";;
     kmeans) optik="clustree";;
       MDSK) optik="clustree";;
        pam) optik="gori";;
       MDSP) optik="clustree";;
      NMDSK) optik="clustree";;
   esac
fi

# Check if codon model is used
if [[ "${cod}" = "y" ]]; then
    mk=92
    mf="-st CODON"
    codonmodel="Yes"
else
    mk=134
    mf=""
    codonmodel="No"
fi


# Show the requirements and settings
echo '
          _____                                    
         / ____\          /|           _         _      /|
        / /    \|        | |          /_|       /_|    | |
        \ \__  __      __| |__      __ _   ___   _   __| |  ___    ____
         \___ \\ \    / /| |\ \    / /| | / _ \ | | / _  | / _ \  / _  \  
      _      \ \\ \  / / | | \ \  / / | || / \ || || / | || |_| || / | | 
      \\_____/ / \ \/ /  | |  \ \/ /  | || \_/ || || \_| |\  __ || \_| |  
       \______/   \  /   |_|   \__/   |_| \___/ |_| \_____\\_\    \_____\
==================/ /===========================================================
=================/ /==================================== U-l-t-i-m-a-t-e =======
                /_/                                                         '
read -p "
 Files checklist: 1.Alignment folder

    Dependencies: 1.IQ-Tree               4.fseqboot
                  2.Newick Utilities      5.Rstudio
                  3.AMAS                  

      R packages: 1.treespace             7.dplyr
                  2.heatmap3              8.foreach
                  3.gplots                9.doParallel
                  4.ggplot2               10.clustree
                  5.tidyr                 11.svglite
                  6.smacof
   *************************************************************
     SETTINGS:

                alignment folder: ${alnf}
                     tree folder: ${tref}
                     codon model: ${codonmodel}
                          lambda: ${lambda}
                  cluster method: ${clustermethod}
                  find optimal k: ${optik}
                         threads: ${thr}
                            seed: ${iqseed}
 
   *************************************************************

Continue?(Y/n): " answer


####################
# Programme starts #
####################
if [[ "${answer}" == "Y" ]] || [[ "${answer}" == "y" ]]; then
   # Check if alignment folder is defined correctly
   if [[ -z "${alnf}" ]] || [[ ! -d "${curdir}/${alnf}" ]]; then 
         echo -e "\nMsg: Some files are missing.\n" 
         usage 
         exit
   fi

# Generate output containing settings
echo '
          _____                                    
         / ____\          /|           _         _      /|
        / /    \|        | |          /_|       /_|    | |
        \ \__  __      __| |__      __ _   ___   _   __| |  ___    ____
         \___ \\ \    / /| |\ \    / /| | / _ \ | | / _  | / _ \  / _  \  
      _      \ \\ \  / / | | \ \  / / | || / \ || || / | || |_| || / | | 
      \\_____/ / \ \/ /  | |  \ \/ /  | || \_/ || || \_| |\  __ || \_| |  
       \______/   \  /   |_|   \__/   |_| \___/ |_| \_____\\_\    \_____\
==================/ /===========================================================
=================/ /==================================== U-l-t-i-m-a-t-e =======
                /_/                                                         ' > ${curdir}/parameter_input

   if [ "${clustermethod}" == "MDSK" ]; then
      echo "  SETTINGS: 
      
                alignment folder: ${alnf}
                     tree folder: ${tref}
                     codon model: ${codonmodel}
                          lambda: ${lambda}
                  cluster method: MDS(Multi-Dimensional Scaling) -> K-means
                  find optimal k: ${optik}
                            seed: ${iqseed}

  Time stamp: $(date)" >> ${curdir}/parameter_input
   elif [ "${clustermethod}" == "MDSP" ]; then
   	  echo "  SETTINGS: 

                alignment folder: ${alnf}
                     tree folder: ${tref}
                     codon model: ${codonmodel}
                          lambda: ${lambda}
                  cluster method: MDS(Multi-Dimensional Scaling) -> PAM
                  find optimal k: ${optik}
                            seed: ${iqseed}

  Time stamp: $(date)" >> ${curdir}/parameter_input
   elif [ "${clustermethod}" == "NMDSK" ]; then
   	  echo "  SETTINGS: 
                
                alignment folder: ${alnf}
                     tree folder: ${tref}
                     codon model: ${codonmodel}
                          lambda: ${lambda}
                  cluster method: NMDS(non-metric Multi-Dimensional Scaling) -> K-means
                  find optimal k: ${optik}
                            seed: ${iqseed}

  Time stamp: $(date)" >> ${curdir}/parameter_input
   else
	 echo "  SETTINGS: 
                
                alignment folder: ${alnf}
                     tree folder: ${tref}
                     codon model: ${codonmodel}
                          lambda: ${lambda}
                  cluster method: ${clustermethod}
                  find optimal k: ${optik}
                            seed: ${iqseed}

  Time stamp: $(date)" >> ${curdir}/parameter_input
   fi

# Define directory of AMAS.py
#read -p $'\nSpecify the directory of AMAS.py (Default is $HOME/Software/amas) ' amasdir
   amasdir="$HOME/Software/amas"

# Print time stamp of beginning the analysis
tstamp=$(date)
echo "
Analysis started at ${tstamp}
--------------------------------------------------------------------------------"


##############################
# Part 1.Building gene trees #
##############################
partindex=1
echo "
Part ${partindex}. Gene trees construction"
SECONDS=0

if [[ -e "${curdir}/${tref}" ]]; then
	fdname=$(echo "${tref}")
else
    fdname="iqMF-autoWZgn_1000UFB"
    mkdir ${curdir}/${fdname} ${curdir}/${fdname}/report ${curdir}/${fdname}/trivia ${curdir}/${fdname}/bs-file

    bsset="-bb 1000 -bnni -wbtl" #Perform Ultra Fast Bootstrapping with 1000 replicates.
    cd ${curdir}/${alnf}/
    parallel --no-notice -j ${thr} "iqtree -s {} ${mf} -AICc -ninit 200 -ntop 50 -nt 1 -seed ${iqseed} ${bsset} -keep-ident -quiet" ::: *.phy

    # File sorting
    mv ${curdir}/${alnf}/*ufboot ${curdir}/${fdname}/bs-file
    mv ${curdir}/${alnf}/*iqtree ${curdir}/${fdname}/report/
    mv ${curdir}/${alnf}/*treefile ${curdir}/${fdname}/
    mv ${curdir}/${alnf}/*log ${curdir}/${alnf}/*gz ${curdir}/${alnf}/*bionj ${curdir}/${alnf}/*mldist ${curdir}/${alnf}/*contree ${curdir}/${alnf}/*splits.nex ${curdir}/${fdname}/trivia
    if [[ -n "${cod}" ]];then mv ${curdir}/${alnf}/*parstree ${curdir}/${fdname}/trivia; fi
fi

# Extract the model information
for i in ${curdir}/${fdname}/report/*iqtree; do
    name=$(basename ${i} | cut -d "." -f 1-2)
    model=$(cat ${i} | grep "Best-fit model according to AICc:" | cut -d " " -f 6)
    echo -e "${name}\t${model}" >> ${curdir}/${alnf}/iq-modelset
done

# Find a single model for permutation analysis
rm -rf ${curdir}/report-temp
mkdir ${curdir}/report-temp
for i in ${curdir}/${fdname}/report/*iqtree; do
    name=$(basename ${i} | cut -d "." -f 1)
    cat ${i} | grep -A${mk} "List of models sorted by AICc scores:" > ${curdir}/report-temp/${name}
done

rm -rf ${curdir}/report-temp2
mkdir ${curdir}/report-temp2
for i in ${curdir}/report-temp/*; do
    name=$(basename ${i})
    lnum=$(cat ${i} | wc -l)
    sed -n "4,${lnum}p" ${i} > ${curdir}/report-temp2/${name}
done
rm -rf ${curdir}/report-temp

rm -rf ${curdir}/report-model
mkdir ${curdir}/report-model
for i in ${curdir}/report-temp2/*; do
    name=$(basename ${i})
    cat ${i} | cut -c 1-17,30-39 > ${curdir}/report-model/${name}.model
done
rm -rf ${curdir}/report-temp2
cd ${curdir}/report-model/
Rscript <(echo "${editor}") 2>&1 >/dev/null
rm -rf ${curdir}/report-model/*model

rm -rf ${curdir}/report-temp
mkdir ${curdir}/report-temp
for i in ${curdir}/report-model/*; do 
    if [[ ! -e ${curdir}/report-temp/00A.txt ]]; then
        cat ${i} | cut -d " " -f 1 > ${curdir}/report-temp/00A.txt
    fi
    name=$(basename ${i})
    cat ${i} | cut -d " " -f 2 > ${curdir}/report-temp/${name}
done
rm -rf ${curdir}/report-model

cd ${curdir}/report-temp/
paste -d " " * > ${curdir}/model.summary
rm -rf ${curdir}/report-temp

cd ${curdir}
Rscript <(echo "${find_model}") 2>&1 >/dev/null
rm -rf ${curdir}/model.summary

kmodel=$(cat ${curdir}/bestmodel.txt | sed -n "1p" | cut -d " " -f 1)

#Root the tree and extract the rooted trees into a file.
stepind=1
aftertreebuild ${curdir} ${fdname} ${stepind}

rm -rf ${curdir}/Trees
mkdir ${curdir}/Trees
mv ${curdir}/${fdname}/ ${curdir}/${fdname}_rooted/ ${curdir}/Trees/

cd ${curdir}

((partindex++))
duration=$SECONDS
tstamp=$(date)
echo "
$(($duration / 60)) minutes,$(($duration % 60)) seconds elapsed.
Time stamp: ${tstamp}

--------------------------------------------------------------------------------"
#*************************************************************

#2.Generate permutation data/concatenation sequence
#*************************************************************
if [[ "${optik}" = "gori" ]]; then
    echo -e "\nPart ${partindex}. Generate permutation data"
    SECONDS=0

    python ${amasdir}/AMAS.py concat -i ${alnf}/*phy -f phylip -d dna -u phylip -t ${curdir}/AutoWZgn_concatenation.phy > /dev/null
    rm -rf ${curdir}/partitions.txt
    sed -i "s/ZF/ZF    /" AutoWZgn_concatenation.phy
    sed -i "s/MW/MW    /" AutoWZgn_concatenation.phy
    sed -i "s/CW/CW    /" AutoWZgn_concatenation.phy
    sed -i "s/BC/BC    /" AutoWZgn_concatenation.phy
    sed -i "s/GRW/GRW    /" AutoWZgn_concatenation.phy
    sed -i "s/CRW/CRW    /" AutoWZgn_concatenation.phy

    seednum=2
    until [[ $((seednum % 2)) -gt 0 ]]; do
        seednum=${RANDOM}
    done

    if [[ -n "${cod}" ]]; then
        if [[ "${pmtmethd}" = "f" ]]; then
           	rm -rf ${curdir}/permutation_data
            mkdir ${curdir}/permutation_data
            cp -p ${curdir}/AutoWZgn_concatenation.phy ${curdir}/permutation_data/
            cd ${curdir}/permutation_data/
            
        	codir=$(pwd)
       	    fname="AutoWZgn_concatenation.phy"
            # Parse the file
            lnum=$(cat ${codir}/${fname} | wc -l)
            info=$(cat ${codir}/${fname} | sed -n "1p")
            chr=$(echo "${info}" | cut -c 1)

            if [[ "${chr}" = " " ]]; then
                len=$(echo "${info}" | cut -d " " -f 3)
            else
            	len=$(echo "${info}" | cut -d " " -f 2)
            fi
     
            cat ${codir}/${fname} | sed -n "1p" > ${codir}/info
            seqend=$((len + 10))
            cat ${codir}/${fname} | sed -n "2,${lnum}p" | cut -c 1-10 > ${codir}/taxa
            cat ${codir}/${fname} | sed -n "2,${lnum}p" | cut -c 11-${seqend} > ${codir}/aln.ori

            # Permute codon
            i=1
            while [[ "${i}" -le 100 ]]; do
            	echo "${i}" >> ${codir}/list
	            ((i++))
            done

            export -f codonjackkniff
            parallel --no-notice -j 4 codonjackkniff ::: ${codir} ::: ${len} :::: ${codir}/list
            rm -rf ${codir}/list ${codir}/taxa ${codir}/info ${codir}/aln.ori
        else
            read -p "Use existant permutation datasets?(Y/n) " usept
            if [[ "${usept}" = "Y" ]] || [[ "${usept}" = "y" ]]; then
                echo -e "\nPlease put them in the folder ${curdir}/permutation_data"
                read -p $"Continue?(Y/n) " conys
                if [[ "${conys}" != "Y" ]] && [[ "${conys}" != "y" ]]; then exit; fi
            else
                echo -e "\nWARNING:The datasets generation process is expensive!"

                rm -rf ${curdir}/permutation_data
                mkdir ${curdir}/permutation_data
                cp -p ${curdir}/AutoWZgn_concatenation.phy ${curdir}/permutation_data/
                cd ${curdir}/permutation_data/
      
                codir=$(pwd)
                fname="AutoWZgn_concatenation.phy"

                # Parse the file
                lnum=$(cat ${codir}/${fname} | wc -l)
                info=$(cat ${codir}/${fname} | sed -n "1p")
                len=$(echo "${info}" | cut -d " " -f 2)
                cat ${codir}/${fname} | sed -n "1p" > ${codir}/info
                seqend=$((len + 10))
                cat ${codir}/${fname} | sed -n "2,${lnum}p" | cut -c 1-10 > ${codir}/taxa
                cat ${codir}/${fname} | sed -n "2,${lnum}p" | cut -c 11-${seqend} > ${codir}/aln.ori

                # Divide into codon
                rm -rf ${codir}/codon
                mkdir ${codir}/codon
                iter=$((len / 3))
                i=1
                posarray=""
                while [[ "${i}" -le "${iter}" ]]; do
                    cdend=$((i * 3))
                    cdstart=$((cdend - 2))
                    cat ${codir}/aln.ori | cut -c ${cdstart}-${cdend} > ${codir}/codon/${i}.pos
                    posarray=$(echo "${posarray} ${i}.pos")
                    ((i++))
                done

                # Permute the codon
                echo "${posarray}" > ${codir}/pos.array
                arraypermute_temp=$(echo "${arraypermute}" | sed "s/seednumber/${seednum}/")
                echo -e "The seed for the generation of the 100-replicate permutation data is: ${seednum}." > ${curdir}/impMsg.txt
                Rscript <(echo "${arraypermute_temp}")
                cat ${codir}/*shuffle > ${codir}/pos.result
                rm -rf ${codir}/*shuffle

                reslnum=$(cat ${codir}/pos.result | wc -l)
                n=$(cat ${codir}/pos.result | sed -n "1p" | grep "pos" | wc -w)
                cd ${codir}/codon
                l=1
                while [[ "${l}" -le "${reslnum}" ]]; do
                    linfo=$(cat ${codir}/pos.result | sed -n "${l}p")
  
                    pf1=$(cat ${codir}/pos.result | sed -n "${l}p" | cut -d " " -f 1)
                    pf2=$(cat ${codir}/pos.result | sed -n "${l}p" | cut -d " " -f 2)
                    paste -d "" ${pf1} ${pf2} > ${codir}/codon/temp0

                    w=3
                    while [[ "${w}" -le "${n}" ]]; do
                        pf=$(cat ${codir}/pos.result | sed -n "${l}p" | cut -d " " -f ${w})
                        paste -d "" ${codir}/codon/temp0 ${pf} > ${codir}/codon/temp
                        rm -rf ${codir}/codon/temp0
                        mv ${codir}/codon/temp ${codir}/codon/temp0
                        ((w++))
                    done
                    mv ${codir}/codon/temp0 ${codir}/temp0
                    paste -d "" ${codir}/taxa ${codir}/temp0 > ${codir}/d${l}.part
                    cat ${codir}/info ${codir}/d${l}.part > ${codir}/d${l}.phy
                    rm -rf ${codir}/d${l}.part ${codir}/temp0
                    ((l++))
                done
                rm -rf ${codir}/codon/ ${codir}/info ${codir}/taxa ${codir}/pos* ${codir}/aln.ori ${codir}/${fname}
            fi
        fi
    else
        fseqboot -sequence ${curdir}/AutoWZgn_concatenation.phy -outfile outfile -test o -seqtype d -rewriteformat p -reps 101 -seed ${seednum} > /dev/null

        taxanum=6
        makedatasets ${curdir} ${taxanum} ${seednum}
        rm -rf ${curdir}/outfile
    fi
else
    echo -e "\nPart ${partindex}. Generate concatenation sequence"
    SECONDS=0

    python ${amasdir}/AMAS.py concat -i ${alnf}/*phy -f phylip -d dna -u phylip -t ${curdir}/AutoWZgn_concatenation.phy > /dev/null
    rm -rf ${curdir}/partitions.txt
    sed -i "s/ZF/ZF    /" AutoWZgn_concatenation.phy
    sed -i "s/MW/MW    /" AutoWZgn_concatenation.phy
    sed -i "s/CW/CW    /" AutoWZgn_concatenation.phy
    sed -i "s/BC/BC    /" AutoWZgn_concatenation.phy
    sed -i "s/GRW/GRW    /" AutoWZgn_concatenation.phy
    sed -i "s/CRW/CRW    /" AutoWZgn_concatenation.phy
fi

((partindex++))
duration=$SECONDS
tstamp=$(date)
echo "
$(($duration / 60)) minutes,$(($duration % 60)) seconds elapsed.
Time stamp: ${tstamp}

--------------------------------------------------------------------------------"
#*************************************************************

#3.Prepare files
#*************************************************************
if [[ "${optik}" = "gori" ]]; then
    echo -e "\nPart ${partindex}. File preparation for permutation analysis"
else
	echo -e "\nPart ${partindex}. File preparation for clustering analysis"
fi

SECONDS=0

#Generate gene trees collection
fdname="iqMF-autoWZgn_br"
if [[ -d "${curdir}/${fdname}" ]]; then rm -rf ${curdir}/${fdname}; fi
mkdir ${curdir}/${fdname} ${curdir}/${fdname}/report ${curdir}/${fdname}/trivia

bsset="" #Don't need nodes support method.
cd ${curdir}/${alnf}/
parallel --no-notice -j ${thr} --colsep '\t' "iqtree -s {1} ${mf} -m {2} -ninit 200 -ntop 50 -nt 1 -seed ${iqseed} ${bsset} -keep-ident -quiet" :::: iq-modelset
mv iq-modelset ${curdir}/

#File sorting
mv ${curdir}/${alnf}/*iqtree ${curdir}/${fdname}/report/
mv ${curdir}/${alnf}/*treefile ${curdir}/${fdname}/
mv ${curdir}/${alnf}/*log ${curdir}/${alnf}/*gz ${curdir}/${alnf}/*bionj ${curdir}/${alnf}/*mldist ${curdir}/${fdname}/trivia
if [[ -n "${cod}" ]];then mv ${curdir}/${alnf}/*parstree ${curdir}/${fdname}/trivia; fi

##Root the tree and extract the rooted trees into a file.
stepind=5
aftertreebuild ${curdir} ${fdname} ${stepind}

mv ${curdir}/${fdname}/ ${curdir}/${fdname}_rooted/ ${curdir}/Trees/

#Get clusters information
rm -rf ${curdir}/Analysis
mkdir ${curdir}/Analysis
mv ${curdir}/gnTrees_collection.tre ${curdir}/Analysis/
if [[ -e ${curdir}/impMsg.txt ]]; then mv ${curdir}/impMsg.txt ${curdir}/Analysis/; fi

cd ${curdir}/Analysis
get_cluster_temp=$(echo "${get_cluster}" | sed "s/args1/${lambda}/" | sed "s/args2/${clustermethod}/")
Rscript <(echo "${get_cluster_temp}") 2>&1 >/dev/null

#Summarize the cluster information for each gene in each number of cluster
kfnum=$(ls ${curdir}/Analysis/*cl | wc -l)
i=1
header=""
while [[ "${i}" -le "${kfnum}" ]]; do
    header=$(echo "${header} k${i}")
    ((i++))
done
echo "genes${header}" > ${curdir}/Analysis/cluster.summary

while read line; do
    kf=2
    ksort=""
    while [[ "${kf}" -le "${kfnum}" ]]; do
    	if [[ "${kf}" -lt 10 ]]; then kfmd=$(echo "k0${kf}.cl"); else kfmd=$(echo "k${kf}.cl"); fi
        name=$(echo "${line}" | cut -d " " -f 1)
        ki=$(cat ${curdir}/Analysis/${kfmd} | grep "${name}" | cut -d " " -f 2)
        ksort=$(echo "${ksort} ${ki}")
        ((kf++))
    done
    echo "${line}${ksort}" >> ${curdir}/Analysis/cluster.summary
done < ${curdir}/Analysis/k01.cl

#Generate order file to guide the summary of cluster assignment
if [[ -e ${curdir}/Analysis/dend.order ]]; then
   	sexyn="n"
    lnum=$(cat ${curdir}/Analysis/dend.order | wc -l)
    i=1
    while [[ "${i}" -le "${lnum}" ]]; do
        name=$(cat ${curdir}/Analysis/dend.order | sed -n "${i}p")
        nsmark=$(echo "${name}" | cut -c 1-2)
        if [[ "${nsmark}" = "ns" ]]; then 
            prefix=$(echo "${name}" | cut -d "_" -f 1)
            sexyn="y"
            echo "${name}" >> ${curdir}/Analysis/Neo.sexpre
        else
            echo "${name}" >> ${curdir}/Analysis/A.auto
        fi
        ((i++))
    done
    rm -rf dend.order

    if [[ "${sexyn}" = "y" ]]; then
        cat ${curdir}/Analysis/Neo.sexpre | sort > ${curdir}/Analysis/Neo.sex
        rm -rf ${curdir}/Analysis/Neo.sexpre
        cat ${curdir}/Analysis/A.auto ${curdir}/Analysis/Neo.sex > ${curdir}/Analysis/order
    else
        mv ${curdir}/Analysis/A.auto ${curdir}/Analysis/order
    fi
    rm -rf ${curdir}/Analysis/A.auto ${curdir}/Analysis/Neo.sex

    if [[ ! -d clinfo ]]; then mkdir clinfo; fi
    mv *cl order clinfo/
fi

if [[ ! -d clinfo ]]; then mkdir clinfo && mv *cl clinfo/; fi

if [[ "${optik}" = "gori" ]]; then
    rm -rf permutation_analysis
    mkdir permutation_analysis
    mv clinfo/ permutation_analysis/

    # Get partition file
    pl_partition ${curdir} ${alnf} permutation_analysis

    # Manoevour the sequence files
    cp -p ${curdir}/AutoWZgn_concatenation.phy ${curdir}/Analysis/permutation_analysis/
    mv ${curdir}/permutation_data/*phy ${curdir}/Analysis/permutation_analysis/
    rmdir ${curdir}/permutation_data
else
    rm -rf optimal_cluster
    mkdir optimal_cluster

    # Get partition file
    pl_partition ${curdir} ${alnf} optimal_cluster
  
    # Manoevour the files
	mv ${curdir}/AutoWZgn_concatenation.phy ${curdir}/Analysis/clinfo/ ${curdir}/Analysis/cluster.summary ${curdir}/Analysis/optimal_cluster/
fi

((partindex++))
duration=$SECONDS
tstamp=$(date)
echo "
$(($duration / 60)) minutes,$(($duration % 60)) seconds elapsed.
Time stamp: ${tstamp}

--------------------------------------------------------------------------------"
#*************************************************************

#4.Permutation analysis/Clustering analysis
#*************************************************************
if [[ "${optik}" = "gori" ]]; then
    echo -e "\nPart ${partindex}. Permutation analysis"
    SECONDS=0

    cd ${curdir}/Analysis/permutation_analysis/
    predir=$(pwd)

    # Create partition-sorted file
    clfi=0
    rm -rf cl_sort
    mkdir cl_sort
    for file in clinfo/*cl; do  
        partSort ${file}
        filename=$(basename ${file})
        ((clfi++))
        clf[$clfi]=$(echo "${filename}_output")
        mv ./clinfo/*cl_output ./cl_sort/
    done

    # Execute the sequence splitting
    ni=0
    for file in *phy; do
        ((ni++))
        name[$ni]=$(echo "${file}" | cut -d "." -f 1)
        mkdir ${name[$ni]}

        exei=1   
        while [[ "${exei}" -le "${clfi}" ]]; do
            if [[ -n "${cod}" ]]; then
                python ${amasdir}/AMAS.py split -f phylip -d dna -i ${file} -l ./cl_sort/${clf[$exei]} -u phylip > /dev/null
            else
                python ${amasdir}/AMAS.py split -f phylip-int -d dna -i ${file} -l ./cl_sort/${clf[$exei]} -u phylip > /dev/null
            fi
            kclnum=$(echo "${clf[$exei]}" | cut -d "." -f 1)
            mkdir ./${name[$ni]}/${kclnum}
            mv ./*cluster* ./${name[$ni]}/${kclnum}/
            ((exei++))
        done
        rm -rf ${file}
   done

   #read -p $'\nContinue to Tree Construction? (y/n): ' totree
   totree="y"
   if [[ "${totree}" = "y" ]] || [[ "${totree}" = "Y" ]]; then
        tri=1
        while [[ "${tri}" -le "${ni}" ]]; do
            trj=1
            while [[ "${trj}" -le "${clfi}" ]]; do
                kclnum=$(echo "${clf[$trj]}" | cut -d "." -f 1)
                cd ${predir}/${name[$tri]}/${kclnum}/
                clnum=1
                for seqfile in *; do
                    directory=$(pwd)
                    echo "${directory}/${seqfile}" >> ${curdir}/permtdata
                    echo "${directory}" >> ${curdir}/permtdir-temp
                done
                ((trj++))
            done
            ((tri++))
        done
   
        cd ${curdir}
        parallel --no-notice -j ${thr} "iqtree -s {} ${mf} -m ${kmodel} -ninit 200 -ntop 50 -nt 1 -seed ${iqseed} -keep-ident -quiet" :::: permtdata
        rm -rf permtdata
   
        cat ${curdir}/permtdir-temp | sort -n | uniq > ${curdir}/permtdir
        rm -rf ${curdir}/permtdir-temp

        export -f logLXtract
        parallel --no-notice -j ${thr} logLXtract ::: ${predir} :::: permtdir > /dev/null
        rm -rf permtdir
        if [[ ! -d "${predir}/logLikelihood" ]]; then mkdir ${predir}/logLikelihood; fi
        mv ${predir}/*logLhcollection ${predir}/logLikelihood/ 
        rm -rf ${predir}/d*

        # Extract log likelihood values from numerous files:
        mkdir ${predir}/value
        cd ${predir}/logLikelihood
        for file in *; do
            name=$(echo "${file}")
            cat ${file} | cut -d $'\t' -f 2 > ${predir}/value/${name}
        done

        mv ${predir}/value/AutoWZgn_concatenation_logLhcollection ${predir}/value/AutoWZgn_concatenation_logLkhcollection

        # Generate logLkhforR.csv file
        cd ${predir}/value
        Rscript <(echo "${logLkhforR_make}") 2>&1 >/dev/null

        # File sorting
        mv ${predir}/value ${predir}/logLikelihood
        mv ${predir}/logLikelihood/value/logLkhcollection.csv ${predir}/logLikelihood/value/logLkhforR.csv ${predir}/
        rm -rf ${predir}/logLikelihood

        # Plot graph
        cd ${predir}
        Rscript <(echo "${graphs}") 2>&1 >/dev/null
        cd ${curdir}/Analysis/
        Rscript -e 'library("clustree"); dd <- read.table("cluster.summary", header = TRUE); p <- clustree(dd, prefix = "k"); ggsave("cluster_summary.svg", width = 12, height = 12)' 2>&1 >/dev/null
 
        # File sorting
        rm -rf ${predir}/a.csv ${predir}/amd.csv ${predir}/b.csv ${predir}/bmd.csv ${predir}/cl_sort
    fi
else
    echo -e "\nPart ${partindex}. Find optimal number of cluster"
    SECONDS=0
    cd ${curdir}/Analysis/optimal_cluster/
    predir=$(pwd)
    Rscript -e 'library("clustree"); dd <- read.table("cluster.summary", header = TRUE); p <- clustree(dd, prefix = "k"); ggsave("cluster_summary.svg", width = 12, height = 12)' 2>&1 >/dev/null
   
    if [[ "${optik}" = "clustree" ]]; then	
        # Visualize the cluster
        sc=1
        while [[ "${sc}" -le 1 ]]; do
         	if [[ -e ${curdir}/Analysis/cluster.visualization ]]; then rm -rf ${curdir}/Analysis/cluster.visualization; fi

            read -p $'\nCheck the cluster_summary.svg and specify the number of cluser to visualize: ' vk
            if [[ "${vk}" -lt 10 ]]; then vkmd=$(echo "k0${vk}.cl"); else vkmd=$(echo "k${vk}/cl"); fi
            echo "genes M1 M2 cluster" > ${curdir}/Analysis/cluster.visualization
            while read line; do
            	name=$(echo "${line}" | cut -d " " -f 1)
            	k=$(cat ${predir}/clinfo/${vkmd} | grep "${name}" | cut -d " " -f 2)
             	echo "${line} ${k}" >> ${curdir}/Analysis/cluster.visualization
            done < ${curdir}/Analysis/2-MDS.coord

            # Plot  
            cd ${curdir}/Analysis/
            Rscript -e 'library(ggplot2); dd <- read.table("cluster.visualization", header = TRUE); dd$cluster <- factor(dd$cluster); p <- ggplot(data = dd, aes(x = M1,y = M2, color = cluster)) + geom_point(pch = 1, size = 3); ggsave("cluster_visualization.svg", width = 12, height = 12)'

            read -p $'\nCheck cluster_visualization.svg.\nAre you happy with the number of cluster?(y/n) ' vkyn
            if [[ "${vkyn}" = "y" ]] || [[ "${vkyn}" == "Y" ]]; then
             	((sc++))
            fi
        done
    fi
fi

((partindex++))
duration=$SECONDS
tstamp=$(date)
echo "
$(($duration / 60)) minutes,$(($duration % 60)) seconds elapsed.
Time stamp: ${tstamp}
--------------------------------------------------------------------------------"
#*************************************************************

#5.Post analysis operation
#*************************************************************
echo "
Part ${partindex}. Post analysis operation"
SECONDS=0

#read -p "continue? " yn
yn="y"
if [ "${yn}" == "y" ]; then

if [ "${optik}" == "clustree" ]; then
   pknum=${vk}

   cd ${predir}
   #Create partition-sorted file
   rm -rf ${predir}/cl_sort
   mkdir ${predir}/cl_sort
   if [ "${pknum}" -gt 10 ]; then pknummd=$(echo "k${pknum}"); else pknummd=$(echo "k0${pknum}"); fi
   partSort ${predir}/clinfo/${pknummd}.cl
   mv ${predir}/clinfo/${pknummd}.cl_output ${predir}/cl_sort/

   #Execute the sequence splitting
   ni=0
   for file in ${predir}/*phy
   do       
     ((ni++))
     name=$(basename "${file}" | cut -d "." -f 1)
     mkdir ${predir}/${name}
     python ${amasdir}/AMAS.py split -f phylip-int -d dna -i ${file} -l ${predir}/cl_sort/${pknummd}.cl_output -u phylip > /dev/null
     mv ${predir}/*cluster*phy ${predir}/${name}/
   done
   
   #Supergene tree construction
   for i in ${predir}/${name}/*phy
   do
     trename=$(basename "${i}" | cut -d "." -f 1 | cut -d "-" -f 1 | cut -d "_" -f 3)
     iqtree -s ${i} ${mf} -m ${kmodel} -ninit 200 -ntop 50 -nt 1 -seed ${iqseed} -keep-ident -quiet
     nw_reroot ${i}.treefile ZF > ${predir}/${name}/${trename}.tre
   done
   
   for t in ${predir}/${name}/*tre
   do
     sgtname=$(basename ${t} | cut -d "." -f 1)
     sgt=$(cat ${t})
     echo "${sgtname} ${sgt}" >> ${curdir}/gnTrees_collection.tre
     rm -rf ${t}
   done
fi

if [ -e ${predir}/logLkhforR.csv ]; then
#Find potential number of clusters
   cd ${predir}/
   Rscript <(echo "${find_potent_knum}") 2>&1 >/dev/null
   pknumall=$(cat potent_knum)
   pknum=$(sed -n "1p" potent_knum)
   read -p $"   
Potential number of clusters are
${pknumall}
Continue with ${pknum} clusters? (y/n): " pkyn
   #pkyn="y"
   if [ -z "${pkyn}" ] || [ "${pkyn}" == "Y" ] || [ "${pkyn}" == "y" ]; then 
      echo "
   *************************************************************************

               Msg:The analysis continues with ${pknum} clusters
     
   *************************************************************************"
   elif [ "${pkyn}" == "n" ] || [ "${pkyn}" == "N" ]; then
      read -p "Reset the number of clusters to: " pknumreset
      if [ -n "${pknumreset}" ] && [ "${pknumreset}" -eq "${pknumreset}" ] 2>/dev/null && [ "${pknumreset}" -le "${clfi}" ]; then
         pknum=${pknumreset}
         echo "
   *************************************************************************
     
              Msg:Number of clusters has been reset to ${pknum} 
                  and the analysis hence continues...
     
   *************************************************************************"
      else
         echo "
   *************************************************************************
     
              Msg:FAILED to reset...
                  the analysis continues with ${pknum} clusters
     
   *************************************************************************"
      fi
   else
      echo "
   *************************************************************************
     
              Msg:FAILED to reset...
                  the analysis continues with ${pknum} clusters
     
   *************************************************************************"
   fi

   if [ -n ${pknum} ]; then

      if [ "${pknum}" -gt 10 ]; then
         pknummd=$(echo "k${pknum}")
      else
         pknummd=$(echo "k0${pknum}")
      fi

      rm -rf ${curdir}/supergn_tree
      mkdir ${curdir}/supergn_tree
      
      mv ${predir}/AutoWZgn_concatenation/${pknummd}/*treefile ${curdir}/supergn_tree

      stepind=9
      #Extract the supergn_tree
      aftertreebuild ${curdir} supergn_tree ${stepind}
      mv ${curdir}/supergn_tree* ${curdir}/Trees/
     
   fi
fi

((partindex++))
duration=$SECONDS
tstamp=$(date)
echo "
$(($duration / 60)) minutes,$(($duration % 60)) seconds elapsed.
Time stamp: ${tstamp}

--------------------------------------------------------------------------------"

fi
#*************************************************************
mv ${curdir}/gnTrees_collection.tre ${curdir}/supergnTrees_collection.tre
mv ${curdir}/supergnTrees_collection.tre ${curdir}/Trees/

tstamp=$(date)
echo "
Congratulations!!
Analysis finished at ${tstamp}"
fi
